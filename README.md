# 테스트 주도 개발

---

> 켄트 백의 Test-Driven Development: By Example을 읽고 정리하고자 합니다.

### 들어가기 전 ..

1. 테스트 주도 개발은 하나의 기술이지만 그 이면에는 사고의 근원적 변화가 있다.
   프로그래머가 자기 작업의 품질에 대한 우선적 책임을 져야하며 TDD를 실천법으로써 책임을 맡는 방법으로
   사용하면 더욱 더 강해질 것이다.

2. 여유를 가져야 한다. 모든 '학습'과 '개선'의 필수적 요소는 자기를 돌아보기와 자기가 생각을 것을 생각하는 메타인식이다.
   따라서 자신이 하는 것을 관조, 관찰하고 기록하고 분석해보아야 한다.
   같은 문제를 여러 번 다른 방법으로 풀어보고 사고과정 중 생각한 것을 직접 입으로 말하도록 하면서 진행하고
   이를 녹음하고 분석하는 프로토콜 분석(protocol analysis)을 해보는 것도 좋은 방법이다.

3. 대규모 프로젝트에서 TDD를 하는 것은 쉽지 않다.
   이럴 때는 두명이서 프로그래밍하는 것도 좋은 방법이다.
   두 사람이 함께 밑단의 시스템이 만족해야 하는 테스트와 그 테스트를 만족하는 밑단의 시스템의 stub을 모두 작성한다.
   이렇게 하면 인터페이스 변경을 제외하고는 결과적으로 두 팀을 디커플링하게 된다.
   (여기서 stub 스텁이란 기존 코드를 흉내내거나 아직 개발되지 않은 코드를 임시로 대치하는 코드를 뜻한다.)

4. TTD의 목표는 작동하는 깔끔한 코드이다.
   이것은 예측 가능한 개발 방법이며 코드가 가르쳐주는 모든 교훈을 학습할 기회를 갖게 된다.

5. 테스트 주도 개발에서의 규칙은 딱 두가지이다.

   - 오직 자동화된 테스트가 실패했을 경우에만 새로운 코드를 작성한다.
   - 중복을 제거한다.
   - 테스트를 쉽게 만드려면 반드시 응집도는 높고 결합도는 낮은 컴포넌트들로 구성되게끔 설계해야 한다.

6. 위의 두가지 규칙에 의해 다음과 같은 순서를 갖게 된다.

   - 빨강 : 실제하는 작은 테스트를 작성한다. 처음에는 컴파일 조차 되지 않을 수도 있다.
   - 초록 : 빨리 테스트가 통과되게끔 한다. 이 떄 어떠한? 짓을 해도 된다.
   - 블루 : 리펙토링을 진행한다.

7. TTD는 프로그래밍을 하면서 나타나는 두려움을 관리하는 개발 방법이다.

8. TTD를 하면서 얻는 장점은 다음과 같다.

   - 결함 밀도를 충분히 감소시킬 수 있다면, 품질보증(QA)을 수동적인 작업에서 능동적인 작업으로 전화할 수 있다.
   - 예외 상황 숫자를 충분히 낮출 수 있다면, 프로젝트 매니저가 정확히 추정할 수 있어 고객을 매일의 개발 과정에 참여시킬 수 있다.
   - 기술적 대화의 주제가 충분히 분명해질 수 있다면, 소프트웨어 엔지니어들은 일일 단위 혹은 주 단위의 협력 대신 분 단위로 협력하면서 일할 수 있다.
   - 한번 더, 결함 밀도가 충분히 낮아진다면, 새 기능의 선적 가능한 소프트웨어를 매일 갖게 되고, 이를 통해 고객과 새로운 비즈니스 관계에 이를 수 있다.

9. 어쨋든 다음과 같이 하자.
   - 단순하게 시작하고
   - 자동화된 테스트를 만들고
   - 새로운 설계 결정을 한 번에 하나씩 도입하기 위해 리팩토링을 할 준비를 하자.

### 1장. 다중 통화를 지원하는 Money 객체

> 다음 예제를 TTD 해보자.
> <img width="567" alt="ex1" src="https://user-images.githubusercontent.com/49556566/193597195-9af8b5c4-2b5c-48c1-81c2-270b6cd8da5a.png"> <img width="594" alt="ex2" src="https://user-images.githubusercontent.com/49556566/193597221-f2aae76e-36d1-4620-a2e1-3b74f5b7fa00.png">
>
> - 통화가 다른 두 금액을 더해서 주어진 환율에 맞게 변한 금액을 결과로 얻을 수 있어야 한다.
> - 어떤 금액(주가)을 어떤 수(주식의 수)에 곱한 금액을 결과로 얻을 수 있어야 한다.
>   이렇게 할 일을 먼저 적고 끝나면 밑줄을 그어주자.

- 스티브 프리만은 테스트와 코드 간의 문제는 중복이 아니라 의존성에 있다.
- 의존성이란 코드나 테스트 중 한쪽을 수정하면 반드시 다른 한쪽도 수정해야만 하는 것이다.
- 프로그램에서는 중복만 제거해주어도 자연스럽게 의존성도 제거되는 경우가 많다.

### 2장. 타락한 객체

> 일반적인 TDD 주기는 다음과 같다.
>
> 1. 테스트를 작성한다. 마음 속에 있는 오퍼레이션이 코드에 어떤 식으로 나타나길 원하는 생각해보라.
>    올바른 답을 얻기 위해 필요한 이야기의 모든 요소를 포함시켜라.
> 2. 실행 가능하게 만든다. 다른 무엇보다도 중요한 것은 빨리 초록 막대를 보는 것이다.
>    만약 깔끔하고 단순한 해법이 있지만 구현하는 데 몇 분 정도 걸릴 것 같으면 일단 적어 놓은 뒤에 원래 문제(초록 막대를 보는 것)으로 돌아오자.
> 3. 올바르게 만든다. 이제 시스템이 작동하므로 직전에 저질렀던 죄악을 수습하자. 좁고 올곧은 소포트웨어 정의의 길로 되돌아와서 중복을 제거하고 초록 막대로 되돌리자.

> 빠르게 초록색을 보기 위해 취할 수 있는 전략 두 가지
>
> 1. 가짜로 구현하기 : 상수를 반환하게 만들고 진짜 코드를 얻을 때까지 단계적으로 상수를 변수로 바꾸어 간다.
> 2. 명백한 구현 사용하기 : 실제 구현을 입력한다.

- 실무에서는 TDD를 사용할 때 두 방법을 번갈아가며 사용한다.
  명백한 구현을 계속 더해 나가며(나에게 명백한 사실이 컴퓨터에게도 명백한 사실인지 확인하기 위해 각각의 명백한 구현 사이에 테스트를 한 번씩 실행한다.)
  빨간 막대를 만나면 가짜로 구현하기 방법을 사용하면서 올바른 코드로 리팩토링한다.

### 3장 모두를 위한 평등

> 일단 삼각측량 기법의 경우 어떻게 리팩토링해야 하는 지 전혀 감이 안 올 때만 사용한다.
> 코드와 테스트 사이의 중복을 제거하고 일반적인 해법을 구할 방법이 보이면 그냥 그 방법대로 구현한다.
> 삼각측량 기법이란 두 개 이상의 테스트를 만들어서 비교하고 동치성(equality)를 일반화하는 것이다.

### 4장 프라이버시

> - private할 수 있는 변수들은 private를 해주자.
> - 오직 테스트를 향상시키기 위해서만 개발된 기능을 사용했다.
> - 두 테스트가 동시에 실패하면 망한다는 점을 인식했다.
> - 위험 요소가 있음에도 계속 진행했다.
> - 테스트와 코드 사이의 결합도를 낮추기 위해, 테스트하는 객체의 새 기능을 사용했다.


### 5장 솔직히 말하자면 

> - 1. 테스트 작성
> - 2. 컴파일되게 하기
> - 3. 실패하는지 확인하기 위해 실행.
> - 4. 실행하게 만듦.
> - 5. 중복 제거 

> 각 단계에는 서로 다른 목적이 있다. 
> 처음 네 단계는 빨리 진행해야 한다. 그러면 새 기능이 포함되더라도 잘 알고 있는 상태에 이를 수 있다. 거기에 도달하기 위해서라면 어떤 죄든 저지를 수 있다. 그동안 만큼은 속도가 설계보다 더 높은 패이기 때문이다. 


### 6장 돌아온 '모두를 위한 평등'

> 중복을 피할 수 있는 방법 중 한 가지는 우리가 만든 클래스 중 하나가 다른 클래스를 상속받게 하는 것이다. 
> 충분한 테스트가 없다면 지원 테스트가 갖춰지지 않은 리펙토링을 만나게 될 수밖에 없다. -> 있으면 좋을 것 같은 테스트를 작성하라. 
